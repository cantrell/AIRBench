<?xml version="1.0" encoding="utf-8"?>
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009" 
		xmlns:s="library://ns.adobe.com/flex/spark"
		xmlns:components="com.adobe.airbench.components.*"
		title="Computation"
		viewActivate="onViewActivate();"
		viewDeactivate="onViewDeactivate();">
	
	<fx:Script>
		<![CDATA[
			import com.adobe.airbench.model.ModelLocator;
			
			import mx.utils.SHA256;
			
			private const COMPUTATION_SHA256:String         = "computation_sha256";
			private const COMPUTATION_SUNRISE_SUNSET:String = "computation_sunrise_sunset";
			private var ml:ModelLocator;
			private const CITIES:Array = [{"lat":37.330804,          "lng":-121.893826,         "utcOffset":-8},  // Adobe San Jose
										  {"lat":47.647949473708856, "lng":-122.34853506088257, "utcOffset":-8},  // Adobe Seattle
										  {"lat":37.770573,          "lng":-122.401645,         "utcOffset":-8},  // Adobe San Francisco
										  {"lat":42.385887,          "lng":-71.263561,          "utcOffset":-5},  // Adobe Boston
										  {"lat":40.752321,          "lng":-73.982692,          "utcOffset":-5},  // Adobe NY
										  {"lat":40.324005,          "lng":-111.68272,          "utcOffset":-7},  // Adobe Utah
										  {"lat":38.928601,          "lng":-77.215712,          "utcOffset":-5},  // Adobe D.C.
										  {"lat":43.64507,           "lng":-79.522058,          "utcOffset":-5},  // Adobe Toronto
										  {"lat":45.402449,          "lng":-75.710488,          "utcOffset":-5},  // Adobe Ottawa
										  {"lat":37.42267078431052,  "lng":-122.08509922027588, "utcOffset":-8}]; // Googleplex
			private const CITY_ITERATIONS:uint = 50;
			
			private function onViewActivate():void
			{
				this.ml = ModelLocator.getInstance();

				// 1. SHA256
				
				var f:File = File.applicationDirectory.resolvePath("test_assets/test_image.jpg");
				var fs:FileStream = new FileStream();
				fs.open(f, FileMode.READ);
				var ba:ByteArray = new ByteArray();
				fs.readBytes(ba);
				this.description.text = this.description.text.replace("$1", (String(Math.round(ba.length / 1024)) + " KB")); 
				this.description.text = this.description.text.replace("$2", String(CITIES.length)); 
				this.description.text = this.description.text.replace("$3", String(CITY_ITERATIONS)); 
				
				var startTime:Number = new Date().time;
				var hash:String = SHA256.computeDigest(ba);
				var totalTimeSHA256:Number = new Date().time - startTime;
				this.ml.testManager.reportPerformanceTestResults(COMPUTATION_SHA256, totalTimeSHA256, "Computation took " + String(totalTimeSHA256) + " ms.");
				this.outputSHA256.text = "Total hash time: " + String(totalTimeSHA256) + " ms";
				
				
				// 2. Sunrise/Sunset
				
				startTime = new Date().time;
				for (var i:uint = 0; i < CITY_ITERATIONS; ++i)
				{
					for each (var city:Object in CITIES)
					{
						var sunData:Object = this.getSunData(city.lat, city.lng, 2, 25, 2008, city.utcOffset);
					}
				}
				var totalTimeSunriseSunset:Number = new Date().time - startTime;
				this.ml.testManager.reportPerformanceTestResults(COMPUTATION_SUNRISE_SUNSET, totalTimeSunriseSunset, "Computation took " + String(totalTimeSunriseSunset) + " ms.");
				this.outputSunriseSunset.text = "Total sunrise/sunset time: " + String(totalTimeSunriseSunset) + " ms";

				this.navBar.testComplete(true, "Test Complete");
			}
			
			private function onViewDeactivate():void
			{
			}

			/**
			 * All the code to calculate sunrise and sunset times is a JavaScript to
			 * ActionScript port of the NOAA Solar Calculator. The original project
			 * can be found here: http://www.esrl.noaa.gov/gmd/grad/solcalc/
			 **/
			private function getSunDataByDate(d:Date, lat:Number, lng:Number):Object
			{
				return this.getSunData(lat, lng, d.month + 1, d.date, d.fullYear, ((d.getTimezoneOffset() / 60) * -1), d.hours, d.minutes, d.seconds);
			}
			
			private function getSunData(lat:Number, lng:Number, month:uint, day:uint, year:uint, utcOffset:int, hours:uint = 12, minutes:uint = 0, seconds:uint = 0):Object
			{
				var jday:Number = this.getJD(month, day, year);
				var tl:Number = (hours * 60) + minutes + (seconds / 60);
				var tz:int = utcOffset * 60;
				var total:Number = jday + tl/1440.0 - tz/24.0;
				var T:Number = calcTimeJulianCent(total);
				var rise:String = calcSunriseSet(true, jday, lat, lng, tz);
				var set:String  = calcSunriseSet(false, jday, lat, lng, tz);
				return {"sunrise":rise, "sunset":set};
			}
			
			private function getJD(month:uint, day:Number, year:Number):Number
			{
				if ((isLeapYear(year)) && (month == 2))
				{
					if (day > 29)
					{
						day = 29;
					} 
				}
				// TBD: Huh?
				if (month <= 2)
				{
					year -= 1;
					month += 12;
				}
				var A:Number = Math.floor(year/100);
				var B:Number = 2 - A + Math.floor(A/4);
				var JD:Number = Math.floor(365.25*(year + 4716)) + Math.floor(30.6001*(month+1)) + day + B - 1524.5;
				return JD;
			}
			
			private function isLeapYear(yr:uint):Boolean 
			{
				return ((yr % 4 == 0 && yr % 100 != 0) || yr % 400 == 0);
			}
			
			private function calcTimeJulianCent(jd:Number):Number
			{
				var T:Number = (jd - 2451545.0)/36525.0;
				return T;
			}
			
			private function calcSunriseSetUTC(rise:Boolean, JD:Number, latitude:Number, longitude:Number):Number
			{
				var t:Number = calcTimeJulianCent(JD);
				var eqTime:Number = calcEquationOfTime(t);
				var solarDec:Number = calcSunDeclination(t);
				var hourAngle:Number = calcHourAngleSunrise(latitude, solarDec);
				if (!rise) hourAngle = -hourAngle;
				var delta:Number = longitude + radToDeg(hourAngle);
				var timeUTC:Number = 720 - (4.0 * delta) - eqTime;	// in minutes
				return timeUTC;
			}
			
			private function calcSunriseSet(rise:Boolean, JD:Number, latitude:Number, longitude:Number, timezone:int):String
			{
				var timeUTC:Number = calcSunriseSetUTC(rise, JD, latitude, longitude);
				var newTimeUTC:Number = calcSunriseSetUTC(rise, JD + timeUTC/1440.0, latitude, longitude); 
				if (!isNaN((newTimeUTC)))
				{
					var timeLocal:Number = newTimeUTC + timezone;
					if ((timeLocal >= 0.0) && (timeLocal < 1440.0))
					{
						return timeString(timeLocal, 2);
					}
				}
				// There is no sunrise or sunset on this date
				return null;
			}
			
			private function calcEquationOfTime(t:Number):Number
			{
				var epsilon:Number = calcObliquityCorrection(t);
				var l0:Number = calcGeomMeanLongSun(t);
				var e:Number = calcEccentricityEarthOrbit(t);
				var m:Number = calcGeomMeanAnomalySun(t);
				var y:Number = Math.tan(degToRad(epsilon)/2.0);
				y *= y;
				var sin2l0:Number = Math.sin(2.0 * degToRad(l0));
				var sinm:Number   = Math.sin(degToRad(m));
				var cos2l0:Number = Math.cos(2.0 * degToRad(l0));
				var sin4l0:Number = Math.sin(4.0 * degToRad(l0));
				var sin2m:Number  = Math.sin(2.0 * degToRad(m));
				var Etime:Number = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;
				return (radToDeg(Etime) * 4.0);	// in minutes of time
			}
			
			private function calcGeomMeanLongSun(t:Number):Number
			{
				var L0:Number = 280.46646 + t * (36000.76983 + t*(0.0003032));
				while(L0 > 360.0)
				{
					L0 -= 360.0
				}
				while(L0 < 0.0)
				{
					L0 += 360.0
				}
				return L0;		// in degrees
			}
			
			private function calcGeomMeanAnomalySun(t:Number):Number
			{
				var M:Number = 357.52911 + t * (35999.05029 - 0.0001537 * t);
				return M;		// in degrees
			}
			
			private function calcEccentricityEarthOrbit(t:Number):Number
			{
				var e:Number = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
				return e;		// unitless
			}
			
			private function calcObliquityCorrection(t:Number):Number
			{
				var e0:Number = calcMeanObliquityOfEcliptic(t);
				var omega:Number = 125.04 - 1934.136 * t;
				var e:Number = e0 + 0.00256 * Math.cos(degToRad(omega));
				return e;		// in degrees
			}
			
			private function calcMeanObliquityOfEcliptic(t:Number):Number
			{
				var seconds:Number = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)));
				var e0:Number = 23.0 + (26.0 + (seconds/60.0))/60.0;
				return e0;		// in degrees
			}
			
			private function calcSunDeclination(t:Number):Number
			{
				var e:Number = calcObliquityCorrection(t);
				var lambda:Number = calcSunApparentLong(t);
				var sint:Number = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));
				var theta:Number = radToDeg(Math.asin(sint));
				return theta;		// in degrees
			}
			
			private function calcSunApparentLong(t:Number):Number
			{
				var o:Number = calcSunTrueLong(t);
				var omega:Number = 125.04 - 1934.136 * t;
				var lambda:Number = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));
				return lambda;		// in degrees
			}
			
			private function calcSunTrueLong(t:Number):Number
			{
				var l0:Number = calcGeomMeanLongSun(t);
				var c:Number = calcSunEqOfCenter(t);
				var O:Number = l0 + c;
				return O;		// in degrees
			}
			
			private function calcSunEqOfCenter(t:Number):Number
			{
				var m:Number = calcGeomMeanAnomalySun(t);
				var mrad:Number = degToRad(m);
				var sinm:Number = Math.sin(mrad);
				var sin2m:Number = Math.sin(mrad+mrad);
				var sin3m:Number = Math.sin(mrad+mrad+mrad);
				var C:Number = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
				return C;		// in degrees
			}
			
			private function calcHourAngleSunrise(lat:Number, solarDec:Number):Number
			{
				var latRad:Number = degToRad(lat);
				var sdRad:Number  = degToRad(solarDec);
				var HAarg:Number = (Math.cos(degToRad(90.833))/(Math.cos(latRad)*Math.cos(sdRad))-Math.tan(latRad) * Math.tan(sdRad));
				var HA:Number = Math.acos(HAarg);
				return HA;		// in radians (for sunset, use -HA)
			}
			
			// flag=2 for HH:MM, 3 for HH:MM:SS
			private function timeString(minutes:int, flag:int):String
			{
				var output:String;
				if ( (minutes >= 0) && (minutes < 1440) )
				{
					var floatHour:Number = minutes / 60.0;
					var hour:int = Math.floor(floatHour);
					var floatMinute:Number = 60.0 * (floatHour - Math.floor(floatHour));
					var minute:int = Math.floor(floatMinute);
					var floatSec:Number = 60.0 * (floatMinute - Math.floor(floatMinute));
					var second:int = Math.floor(floatSec + 0.5);
					if (second > 59)
					{
						second = 0;
						minute += 1;
					}
					if ((flag == 2) && (second >= 30)) minute++;
					if (minute > 59)
					{
						minute = 0;
						hour += 1;
					}
					output = zeroPad(hour,2) + ":" + zeroPad(minute,2);
					if (flag > 2) output = output + ":" + zeroPad(second,2);
				}
				else
				{
					output = "error";
				}
				return output;
			}
			
			private function zeroPad(n:Number, digits:int):String
			{
				var s:String = n.toString();
				while (s.length < digits)
				{
					s = "0" + s;
				}
				return s;
			}
			
			private function radToDeg(angleRad:Number):Number 
			{
				return (180.0 * angleRad / Math.PI);
			}
			
			private function degToRad(angleDeg:Number):Number 
			{
				return (Math.PI * angleDeg / 180.0);
			}
			
		]]>
	</fx:Script>
	<s:VGroup width="100%" height="100%">
		<s:Scroller width="100%" height="100%">
			<s:VGroup width="100%" height="100%" horizontalAlign="center" verticalAlign="middle" gap="20">
				<components:MultiLineLabel id="description" text="This test measures now long it takes to calculate a SHA256 hash on a $1 image, and to calculate sunrise and sunset times for $2 cities, $3 times."/>
				<s:Label id="outputSHA256" fontWeight="bold"/>
				<s:Label id="outputSunriseSunset" fontWeight="bold"/>
			</s:VGroup>
		</s:Scroller>
		<components:NavigationBar id="navBar" width="100%"/>
	</s:VGroup>
</s:View>